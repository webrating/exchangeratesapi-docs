---
title: 'Status'
openapi: 'GET /status'
description: 'Check the operational status of the Exchange Rates API and when data was last updated'
---

## Overview

The status endpoint provides real-time information about the API's operational status and data freshness. This endpoint is **public** and doesn't require authentication.

<Note>
This endpoint is perfect for health checks and monitoring integrations. It's unlimited and cached at the edge for optimal performance.
</Note>

## Request

<CodeGroup>

```bash cURL
curl https://api.exchangeratesapi.com.au/status
```

```javascript JavaScript
const response = await fetch('https://api.exchangeratesapi.com.au/status');
const data = await response.json();
console.log('API Status:', data.status);
```

```python Python
import requests

response = requests.get('https://api.exchangeratesapi.com.au/status')
data = response.json()
print(f"API Status: {data['status']}")
```

```php PHP
<?php
$response = file_get_contents('https://api.exchangeratesapi.com.au/status');
$data = json_decode($response, true);
echo "API Status: " . $data['status'];
?>
```

</CodeGroup>

## Response

<ResponseExample>

```json Success Response
{
  "status": "operational",
  "last_update": "2025-09-01T06:17:41.202Z",
  "stale": false,
  "region": "SYD",
  "version": "1.0",
  "uptime": "99.97%"
}
```

</ResponseExample>

<ResponseField name="status" type="string" required>
  Current operational status of the API
  
  **Possible values:**
  - `operational` - API is fully functional
  - `degraded` - API is experiencing issues but functional
  - `outage` - API is experiencing a full outage
</ResponseField>

<ResponseField name="last_update" type="string" required>
  ISO 8601 timestamp of when RBA data was last successfully fetched and processed
</ResponseField>

<ResponseField name="stale" type="boolean" required>
  Indicates if the current data is stale (older than expected)
  
  - `false` - Data is fresh (within expected timeframe)
  - `true` - Data is stale (RBA update may have failed)
</ResponseField>

<ResponseField name="region" type="string" required>
  Cloudflare data center that processed the request (e.g., "SYD", "MEL", "BNE")
</ResponseField>

<ResponseField name="version" type="string">
  Current API version number
</ResponseField>

<ResponseField name="uptime" type="string">
  Rolling 30-day uptime percentage
</ResponseField>

## Status Codes

| Status | Description |
|--------|-------------|
| `operational` | All systems functioning normally |
| `degraded` | Minor issues detected, API still functional |
| `outage` | Major issues, API may not be functioning |

## Data Freshness

The Exchange Rates API fetches RBA data daily at **4:00 PM AEST**. The `stale` field helps you understand data freshness:

### Fresh Data (`stale: false`)
- Last update was within expected timeframe (usually within 2 hours of 4 PM AEST)
- RBA data fetch was successful
- All systems operating normally

### Stale Data (`stale: true`)  
- Last update was longer ago than expected
- May indicate RBA website issues
- Automatic fallback to previous day's rates is active
- Additional headers will be present on rate endpoints:
  - `X-Data-Stale: true`
  - `X-RBA-Source-Date: YYYY-MM-DD`

## Monitoring Integration

### Health Check Example

```javascript
async function healthCheck() {
  try {
    const response = await fetch('https://api.exchangeratesapi.com.au/status');
    const data = await response.json();
    
    if (data.status === 'operational' && !data.stale) {
      return { healthy: true, message: 'API operational with fresh data' };
    } else if (data.status === 'operational' && data.stale) {
      return { 
        healthy: true, 
        warning: 'API operational but data may be stale',
        lastUpdate: data.last_update 
      };
    } else {
      return { 
        healthy: false, 
        error: `API status: ${data.status}`,
        lastUpdate: data.last_update
      };
    }
  } catch (error) {
    return { healthy: false, error: 'Failed to reach API' };
  }
}
```

### Nagios/Zabbix Integration

```bash
#!/bin/bash
# Health check script for monitoring systems

STATUS=$(curl -s https://api.exchangeratesapi.com.au/status | jq -r '.status')

case $STATUS in
  "operational")
    echo "OK - Exchange Rates API is operational"
    exit 0
    ;;
  "degraded")
    echo "WARNING - Exchange Rates API is degraded"
    exit 1
    ;;
  "outage")
    echo "CRITICAL - Exchange Rates API is experiencing an outage"
    exit 2
    ;;
  *)
    echo "UNKNOWN - Could not determine API status"
    exit 3
    ;;
esac
```

## Response Headers

```http
HTTP/2 200 OK
Content-Type: application/json
Cache-Control: no-store
X-Request-Id: 123e4567-e89b-12d3-a456-426614174000
X-Response-Time: 45ms
CF-Cache-Status: MISS
CF-Ray: 8a1b2c3d4e5f6789-SYD
```

<Note>
The status endpoint returns `Cache-Control: no-store` to ensure you always get current status information rather than cached responses.
</Note>

## Use Cases

### Application Health Checks
Monitor your application's dependency on the Exchange Rates API:

```javascript
// Check API health before making rate requests
const statusCheck = await fetch('https://api.exchangeratesapi.com.au/status');
const status = await statusCheck.json();

if (status.status !== 'operational') {
  console.warn('Exchange Rates API is not operational, using cached rates');
  return getCachedRates();
}
```

### Status Page Integration
Display API status on your own status page:

```javascript
async function getAPIStatus() {
  const response = await fetch('https://api.exchangeratesapi.com.au/status');
  const data = await response.json();
  
  return {
    service: 'Exchange Rates API',
    status: data.status,
    lastUpdate: data.last_update,
    isStale: data.stale,
    uptime: data.uptime
  };
}
```

### Scheduled Monitoring
Set up automated monitoring to track API reliability:

```python
import requests
import time
from datetime import datetime

def monitor_api():
    try:
        response = requests.get('https://api.exchangeratesapi.com.au/status', timeout=30)
        data = response.json()
        
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'status': data['status'],
            'stale': data['stale'],
            'response_time': response.elapsed.total_seconds(),
            'region': data['region']
        }
        
        # Log to your monitoring system
        print(f"API Status: {data['status']} | Stale: {data['stale']} | Response: {response.elapsed.total_seconds()}s")
        
    except Exception as e:
        print(f"Failed to check API status: {e}")

# Run every 5 minutes
while True:
    monitor_api()
    time.sleep(300)
```

## Error Responses

While the status endpoint is highly reliable, it may occasionally return errors:

```json
{
  "success": false,
  "error": {
    "code": 503,
    "type": "service_unavailable", 
    "info": "Status service temporarily unavailable"
  }
}
```

In such cases, you should assume the API may be experiencing issues and implement appropriate fallback logic in your applications.